import React from 'react';
import _extends from '@babel/runtime/helpers/esm/extends';
import _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';

let GestureFlag;

(function (GestureFlag) {
  GestureFlag["OnStart"] = "start";
  GestureFlag["OnChange"] = "change";
  GestureFlag["OnEnd"] = "end";
})(GestureFlag || (GestureFlag = {}));

const noop = () => {};
const chainFns = function chainFns() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(fn => fn(...args));
  };
};
const addV = (v1, v2) => v1.map((v, i) => v + v2[i]);
const subV = (v1, v2) => v1.map((v, i) => v - v2[i]);

const setListeners = add => (el, listeners, options) => {
  const action = add ? 'addEventListener' : 'removeEventListener';
  listeners.forEach((_ref) => {
    let [type, fn] = _ref;
    return el[action](type, fn, options);
  });
};

const addListeners = setListeners(true);
const removeListeners = setListeners(false);
function getModifierKeys(event) {
  const {
    shiftKey,
    altKey,
    metaKey,
    ctrlKey
  } = event;
  return {
    shiftKey,
    altKey,
    metaKey,
    ctrlKey
  };
}
function getScrollEventData(event) {
  const {
    scrollX,
    scrollY,
    scrollLeft,
    scrollTop
  } = event.currentTarget;
  return _extends({
    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]
  }, getModifierKeys(event));
}
function getWheelEventData(event) {
  const {
    deltaX,
    deltaY
  } = event;
  return _extends({
    values: [deltaX, deltaY]
  }, getModifierKeys(event));
}
function getPointerEventData(event) {
  const {
    touches,
    buttons,
    changedTouches
  } = event;
  const touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;
  const {
    clientX,
    clientY
  } = touchEvents ? touchEvents[0] : event;
  const down = touchEvents && touchEvents.length > 0 || buttons > 0;
  return _extends({
    values: [clientX, clientY],
    touches: touchEvents && touchEvents.length || 0,
    down,
    buttons
  }, getModifierKeys(event));
}
function getTwoTouchesEventData(event) {
  const {
    touches
  } = event;
  const dx = touches[1].clientX - touches[0].clientX;
  const dy = touches[1].clientY - touches[0].clientY;
  const da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];
  const origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];
  return _extends({
    values: da,
    origin,
    touches: 2,
    down: touches.length > 0
  }, getModifierKeys(event));
}
function calculateVelocity(diff, delta_t, len) {
  len = len || Math.hypot(...diff);
  return delta_t ? len / delta_t : 0;
}
function calculateVelocities(diff, delta_t) {
  return delta_t ? diff.map(v => v / delta_t) : Array(diff.length).fill(0);
}
function calculateDistance(delta) {
  return Math.hypot(...delta);
}
function calculateDirection(diff, len) {
  len = len || Math.hypot(...diff) || 1;
  return diff.map(v => v / len);
}
function calculateAllKinematics(delta, diff, delta_t) {
  const len = Math.hypot(...diff);
  return {
    velocities: calculateVelocities(diff, delta_t),
    velocity: calculateVelocity(diff, delta_t, len),
    distance: calculateDistance(delta),
    direction: calculateDirection(diff, len)
  };
}
function supportsGestureEvent() {
  try {
    return 'constructor' in GestureEvent;
  } catch (e) {
    return false;
  }
}

const mappedKeys = {
  drag: {
    stateKey: 'drag',
    handlerKey: 'onDrag'
  },
  pinch: {
    stateKey: 'pinch',
    handlerKey: 'onPinch'
  },
  move: {
    stateKey: 'move',
    handlerKey: 'onMove'
  },
  scroll: {
    stateKey: 'scroll',
    handlerKey: 'onScroll'
  },
  wheel: {
    stateKey: 'wheel',
    handlerKey: 'onWheel'
  },
  hover: {
    stateKey: 'move',
    handlerKey: 'onHover'
  }
};
const defaultConfig = {
  domTarget: undefined,
  event: {
    passive: true,
    capture: false
  },
  pointerEvents: false,
  window: typeof window !== 'undefined' ? window : undefined,
  transform: {
    x: _x => _x,
    y: _y => _y
  },
  enabled: true,
  drag: true,
  pinch: true,
  scroll: true,
  wheel: true,
  hover: true,
  move: true
};
const initialCommon = {
  event: undefined,
  currentTarget: undefined,
  pointerId: undefined,
  values: [0, 0],
  velocities: [0, 0],
  delta: [0, 0],
  initial: [0, 0],
  previous: [0, 0],
  transform: undefined,
  local: [0, 0],
  lastLocal: [0, 0],
  first: false,
  last: false,
  active: false,
  time: undefined,
  cancel: noop,
  canceled: false,
  temp: undefined,
  args: undefined
};
const initialCoordinates = {
  xy: [0, 0],
  vxvy: [0, 0],
  velocity: 0,
  distance: 0,
  direction: [0, 0]
};
const initialDistanceAngle = {
  da: [0, 0],
  vdva: [0, 0],
  origin: [0, 0],
  turns: 0
};
const initialState = {
  shared: {
    hovering: false,
    scrolling: false,
    wheeling: false,
    dragging: false,
    moving: false,
    pinching: false,
    touches: 0,
    buttons: 0,
    down: false,
    shiftKey: false,
    altKey: false,
    metaKey: false,
    ctrlKey: false
  },
  move: _extends({}, initialCommon, initialCoordinates),
  drag: _extends({}, initialCommon, initialCoordinates),
  scroll: _extends({}, initialCommon, initialCoordinates),
  wheel: _extends({}, initialCommon, initialCoordinates),
  pinch: _extends({}, initialCommon, initialDistanceAngle)
};
const genericEndState = {
  first: false,
  last: true,
  active: false
};

class Recognizer {
  constructor(gestureKey, controller, args) {
    var _this = this;

    if (args === void 0) {
      args = [];
    }

    this.gestureKey = gestureKey;
    this.controller = controller;
    this.args = args;
    this.stateKey = void 0;

    this.isEnabled = () => {
      return this.controller.config.enabled && this.controller.config[this.gestureKey];
    };

    this.setTimeout = function (callback, ms) {
      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      _this.controller.timeouts[_this.stateKey] = window.setTimeout(callback, ms, ...args);
    };

    this.clearTimeout = () => {
      clearTimeout(this.controller.timeouts[this.stateKey]);
    };

    this.getState = () => this.controller.state[this.stateKey];

    this.getSharedState = () => this.controller.state.shared;

    this.pointerEventsEnabled = () => this.controller.config.pointerEvents;

    this.getTransformConfig = () => this.controller.config.transform;

    this.addWindowListeners = listeners => {
      this.controller.addWindowListeners(this.stateKey, listeners);
    };

    this.removeWindowListeners = () => {
      this.controller.removeWindowListeners(this.stateKey);
    };

    this.updateState = (sharedState, gestureState, gestureFlag) => {
      this.controller.updateState(sharedState, gestureState, this.gestureKey, gestureFlag);
    };

    this.getStartState = (values, event) => {
      const state = this.getState();
      const initial = initialState[this.stateKey];
      const transform = state.transform || event.transform || this.getTransformConfig();
      const lastLocal = state.local || initial.local;
      return _extends({}, initial, {
        event,
        values,
        initial: values,
        previous: values,
        local: lastLocal,
        lastLocal,
        first: true,
        active: true,
        transform,
        time: event.timeStamp,
        args: this.args
      });
    };

    this.stateKey = mappedKeys[gestureKey].stateKey;
  }

}

class CoordinatesRecognizer extends Recognizer {
  constructor() {
    super(...arguments);

    this.getKinematics = (values, event) => {
      const state = this.getState();
      const {
        values: xy,
        initial,
        lastLocal,
        time = 0
      } = state;
      const transform = state.transform || event.transform || this.getTransformConfig();
      const delta = subV(values, initial).map((v, i) => Object.values(transform)[i](v));
      const diff = subV(values, xy).map((v, i) => Object.values(transform)[i](v));
      const delta_t = event.timeStamp - time;
      const {
        velocity,
        velocities,
        distance,
        direction
      } = calculateAllKinematics(delta, diff, delta_t);
      return {
        event,
        values,
        delta,
        velocity,
        velocities,
        distance,
        direction,
        local: addV(lastLocal, delta),
        previous: xy,
        transform,
        time: event.timeStamp
      };
    };
  }

}

class DragRecognizer extends CoordinatesRecognizer {
  constructor(controller, args) {
    super('drag', controller, args);

    this.onStart = event => {
      if (!this.isEnabled()) return;

      const _getPointerEventData = getPointerEventData(event),
            {
        values
      } = _getPointerEventData,
            rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      if (rest.touches > 1) return;
      const {
        currentTarget,
        pointerId
      } = event;

      if (this.pointerEventsEnabled()) {
        currentTarget && currentTarget.setPointerCapture(pointerId);
      } else {
        this.removeWindowListeners();
        const dragListeners = [['mousemove', this.onChange], ['mouseup', this.onEnd], ['touchmove', this.onChange], ['touchend', this.onEnd], ['touchcancel', this.onEnd]];
        this.addWindowListeners(dragListeners);
      }

      const startState = this.getStartState(values, event);
      this.updateState(_extends({}, rest, {
        dragging: true,
        down: true
      }), _extends({}, startState, {
        currentTarget,
        pointerId,
        cancel: () => this.onCancel(event)
      }), GestureFlag.OnStart);
    };

    this.onChange = event => {
      const {
        canceled,
        active
      } = this.getState();
      if (canceled || !active) return;

      const _getPointerEventData2 = getPointerEventData(event),
            {
        values
      } = _getPointerEventData2,
            rest = _objectWithoutPropertiesLoose(_getPointerEventData2, ["values"]);

      if (rest.buttons === 0 && rest.touches === 0) {
        this.onEnd(event);
        return;
      }

      const kinematics = this.getKinematics(values, event);

      const cancel = () => this.onCancel(event);

      this.updateState(rest, _extends({}, kinematics, {
        first: false,
        cancel
      }), GestureFlag.OnChange);
    };

    this.onEnd = event => {
      const state = this.getState();
      if (!state.active) return;
      const {
        currentTarget,
        pointerId
      } = state;
      if (currentTarget && this.pointerEventsEnabled()) currentTarget.releasePointerCapture(pointerId);else this.removeWindowListeners();
      this.updateState({
        dragging: false,
        down: false,
        buttons: 0,
        touches: 0
      }, _extends({}, genericEndState, {
        event
      }), GestureFlag.OnEnd);
    };

    this.onCancel = event => {
      this.updateState(null, {
        canceled: true,
        cancel: noop
      });
      requestAnimationFrame(() => this.onEnd(event));
    };
  }

  getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]];
    }

    return [[['onMouseDown', 'onTouchStart'], this.onStart]];
  }

}

class ScrollRecognizer extends CoordinatesRecognizer {
  constructor(controller, args) {
    super('scroll', controller, args);

    this.onChange = event => {
      if (!this.isEnabled()) return;
      this.clearTimeout();
      this.setTimeout(this.onEnd, 100);

      const _getScrollEventData = getScrollEventData(event),
            {
        values
      } = _getScrollEventData,
            rest = _objectWithoutPropertiesLoose(_getScrollEventData, ["values"]);

      if (!this.getState().active) {
        const startState = this.getStartState(values, event);
        this.updateState(_extends({
          scrolling: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        const kinematics = this.getKinematics(values, event);
        this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    this.onEnd = () => {
      if (!this.getState().active) return;
      this.updateState({
        scrolling: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };
  }

  getEventBindings() {
    return [['onScroll', this.onChange]];
  }

}

class WheelRecognizer extends CoordinatesRecognizer {
  constructor(controller, args) {
    super('wheel', controller, args);

    this.onChange = event => {
      if (!this.isEnabled()) return;
      this.clearTimeout();
      this.setTimeout(this.onEnd, 100);

      const _getWheelEventData = getWheelEventData(event),
            {
        values: eventValues
      } = _getWheelEventData,
            rest = _objectWithoutPropertiesLoose(_getWheelEventData, ["values"]);

      const values = addV(eventValues, this.getState().values);

      if (!this.getState().active) {
        const startState = this.getStartState(values, event);
        this.updateState(_extends({
          wheeling: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        const kinematics = this.getKinematics(values, event);
        this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    this.onEnd = () => {
      if (!this.getState().active) return;
      this.updateState({
        wheeling: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };
  }

  getEventBindings() {
    return [['onWheel', this.onChange]];
  }

}

class MoveRecognizer extends CoordinatesRecognizer {
  constructor(controller, args) {
    super('move', controller, args);

    this.onChange = event => {
      if (!this.isEnabled()) return;
      this.clearTimeout();
      this.setTimeout(this.onEnd, 100);

      const _getPointerEventData = getPointerEventData(event),
            {
        values
      } = _getPointerEventData,
            rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      if (!this.getState().active) {
        const startState = this.getStartState(values, event);
        this.updateState(_extends({
          moving: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        const kinematics = this.getKinematics(values, event);
        this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    this.onEnd = () => {
      if (!this.getState().active) return;
      this.updateState({
        moving: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };
  }

  getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerMove', this.onChange]];
    }

    return [['onMouseMove', this.onChange]];
  }

}

class HoverRecognizer extends CoordinatesRecognizer {
  constructor(controller, args) {
    super('hover', controller, args);

    this.onStart = event => {
      if (!this.isEnabled()) return;

      const _getPointerEventData = getPointerEventData(event),
            {
        values
      } = _getPointerEventData,
            rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      this.updateState(_extends({
        hovering: true
      }, rest), {
        values,
        event,
        args: this.args
      }, GestureFlag.OnChange);
    };

    this.onEnd = event => {
      if (!this.isEnabled()) return;

      const _getPointerEventData2 = getPointerEventData(event),
            {
        values
      } = _getPointerEventData2,
            rest = _objectWithoutPropertiesLoose(_getPointerEventData2, ["values"]);

      const kinematics = this.getKinematics(values, event);
      this.updateState(_extends({
        hovering: false,
        moving: false
      }, rest), _extends({}, kinematics, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }));
      this.controller.fireGestureHandler('move', GestureFlag.OnEnd);
      this.controller.fireGestureHandler('hover', GestureFlag.OnChange);
    };
  }

  getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]];
    }

    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]];
  }

}

class DistanceAngleRecognizer extends Recognizer {
  constructor() {
    super(...arguments);

    this.getKinematics = (_ref, event) => {
      let [d, a] = _ref;
      const state = this.getState();
      const {
        values: da,
        turns,
        initial,
        lastLocal,
        time = 0
      } = state;
      a = a === undefined ? da[1] : a;
      const diff_d = d - da[0];
      let diff_a = a - da[1];
      const newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns;
      diff_a -= 360 * newTurns;
      const delta_d = d - initial[0];
      const delta_a = a - 360 * newTurns - initial[1];
      const delta = [delta_d, delta_a];
      const delta_t = event.timeStamp - time;
      const velocities = calculateVelocities([diff_d, diff_a], delta_t);
      return {
        event,
        values: [d, a],
        delta,
        velocities,
        turns: newTurns,
        local: addV(lastLocal, delta),
        previous: da,
        time: event.timeStamp
      };
    };
  }

}

class PinchRecognizer extends DistanceAngleRecognizer {
  constructor(controller, args) {
    super('pinch', controller, args);

    this.onStart = event => {
      if (!this.isEnabled() || event.touches.length !== 2) return;

      const _getTwoTouchesEventDa = getTwoTouchesEventData(event),
            {
        values,
        origin
      } = _getTwoTouchesEventDa,
            rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, ["values", "origin"]);

      const startState = this.getStartState(values, event);
      this.updateState(_extends({}, rest, {
        pinching: true,
        down: true
      }), _extends({}, startState, {
        origin,
        cancel: () => this.onCancel(event)
      }), GestureFlag.OnStart);
    };

    this.onChange = event => {
      const {
        canceled,
        active
      } = this.getState();
      if (canceled || !active || event.touches.length !== 2) return;

      const _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),
            {
        values,
        origin
      } = _getTwoTouchesEventDa2,
            rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa2, ["values", "origin"]);

      const kinematics = this.getKinematics(values, event);

      const cancel = () => this.onCancel(event);

      this.updateState(rest, _extends({}, kinematics, {
        origin,
        first: false,
        cancel
      }), GestureFlag.OnChange);
    };

    this.onEnd = event => {
      if (!this.getState().active) return;
      this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState, {
        event
      }), GestureFlag.OnEnd);
    };

    this.onCancel = event => {
      this.updateState(null, {
        canceled: true,
        cancel: noop
      });
      requestAnimationFrame(() => this.onEnd(event));
    };
  }

  getEventBindings() {
    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];
  }

}

class PinchWheelRecognizer extends DistanceAngleRecognizer {
  constructor(controller, args) {
    super('pinch', controller, args);

    this.onChange = event => {
      if (!this.isEnabled() || !event.ctrlKey) return;
      event.preventDefault();
      this.clearTimeout();
      this.setTimeout(this.onEnd, 100);

      const _getWheelEventData = getWheelEventData(event),
            {
        values
      } = _getWheelEventData,
            rest = _objectWithoutPropertiesLoose(_getWheelEventData, ["values"]);

      const d = this.getState().values[0] - values[1];

      if (!this.getState().active) {
        const startState = this.getStartState([d, 0], event);
        this.updateState(_extends({
          pinching: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        const kinematics = this.getKinematics([d, undefined], event);
        this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    this.onEnd = () => {
      if (!this.getState().active) return;
      this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState), GestureFlag.OnEnd);
    };
  }

  getEventBindings() {
    return [['onWheel', this.onChange]];
  }

}

const SCALE_FACTOR = 260;
class PinchWebKitGestureRecognizer extends DistanceAngleRecognizer {
  constructor(controller, args) {
    super('pinch', controller, args);

    this.onStart = event => {
      if (!this.isEnabled()) return;
      event.preventDefault();
      const da = [event.scale * SCALE_FACTOR, event.rotation];
      const startState = this.getStartState(da, event);
      this.updateState({
        pinching: true,
        down: true,
        touches: 2
      }, _extends({}, startState, {
        cancel: () => this.onCancel(event)
      }), GestureFlag.OnStart);
    };

    this.onChange = event => {
      const {
        canceled,
        active
      } = this.getState();
      if (canceled || !active) return;
      event.preventDefault();
      const da = [event.scale * SCALE_FACTOR, event.rotation];
      const kinematics = this.getKinematics(da, event);

      const cancel = () => this.onCancel(event);

      this.updateState(null, _extends({}, kinematics, {
        first: false,
        cancel
      }), GestureFlag.OnChange);
    };

    this.onEnd = event => {
      if (!this.getState().active) return;
      event.preventDefault();
      this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState, {
        event
      }), GestureFlag.OnEnd);
    };

    this.onCancel = event => {
      this.updateState(null, {
        canceled: true,
        cancel: noop
      });
      requestAnimationFrame(() => this.onEnd(event));
    };

    this.updateTouchData = event => {
      const {
        origin
      } = getTwoTouchesEventData(event);
      this.updateState(null, {
        origin
      });
    };
  }

  getEventBindings() {
    return [['onGestureStart', this.onStart], ['onGestureChange', this.onChange], [['onGestureEnd', 'onTouchCancel'], this.onEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];
  }

}

class GestureController {
  constructor(_handlers, _config) {
    var _this = this;

    this.handlers = void 0;
    this.config = void 0;
    this.state = initialState;
    this.timeouts = {};
    this.bindings = {};
    this.domListeners = [];
    this.windowListeners = {};

    this.setHandlersAndConfig = (handlers, config) => {
      if (typeof handlers === 'function') handlers = {
        onDrag: handlers
      };else if (handlers.onAction) {
        handlers.onDrag = handlers.onAction;
        delete handlers.onAction;
      }
      this.config = _extends({}, defaultConfig, config);
      const {
        domTarget
      } = this.config;
      const realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;
      this.config.domTarget = realDomTarget;
      this.handlers = handlers;
    };

    this.clean = () => {
      this.cleanOnBind();
      Object.values(this.timeouts).forEach(clearTimeout);
      Object.keys(this.windowListeners).forEach(stateKey => this.removeWindowListeners(stateKey));
    };

    this.cleanOnBind = () => {
      this.bindings = {};
      const {
        domTarget
      } = this.config;

      if (domTarget) {
        removeListeners(domTarget, this.domListeners, this.config.event);
        this.domListeners = [];
      }
    };

    this.updateState = (sharedState, gestureState, gestureKey, gestureFlag) => {
      const stateKey = mappedKeys[gestureKey].stateKey;
      this.state = _extends({}, this.state, {
        shared: _extends({}, this.state.shared, sharedState),
        [stateKey]: _extends({}, this.state[stateKey], gestureState)
      });

      if (gestureFlag) {
        this.fireGestureHandler(gestureKey, gestureFlag);
      }
    };

    this.fireGestureHandler = (gestureKey, gestureFlag) => {
      const {
        stateKey,
        handlerKey
      } = mappedKeys[gestureKey];

      const state = _extends({}, this.state.shared, this.state[stateKey]);

      if (gestureKey === 'pinch') {
        const pinchState = state;
        pinchState.da = state.values;
        pinchState.vdva = state.velocities;
      } else {
        const coordinatesState = state;
        coordinatesState.xy = state.values;
        coordinatesState.vxvy = state.velocities;
      }

      if (gestureFlag === GestureFlag.OnStart) {
        const handlerStart = handlerKey + "Start";
        const handler = this.handlers[handlerStart];
        handler && handler(state);
      }

      const handler = this.handlers[handlerKey];

      if (handler) {
        this.state[stateKey].temp = handler(state) || this.state[stateKey].temp;
      }

      if (gestureFlag === GestureFlag.OnEnd) {
        const handlerEnd = handlerKey + "End";
        const handler = this.handlers[handlerEnd];
        handler && handler(state);
      }
    };

    this.addWindowListeners = (stateKey, listeners) => {
      if (!this.config.window) return;
      this.windowListeners[stateKey] = listeners;
      addListeners(this.config.window, listeners, this.config.event);
    };

    this.removeWindowListeners = stateKey => {
      if (!this.config.window) return;
      const listeners = this.windowListeners[stateKey];

      if (listeners) {
        removeListeners(this.config.window, listeners, this.config.event);
        delete this.windowListeners[stateKey];
      }
    };

    this.addRecognizer = recognizer => {
      recognizer.getEventBindings().map(this.addEventBindings);
    };

    this.addEventBindings = (_ref) => {
      let [eventNames, fn] = _ref;
      const eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;
      eventNamesArray.forEach(eventName => {
        this.bindings[eventName] = this.bindings[eventName] ? [...this.bindings[eventName], fn] : [fn];
      });
    };

    this.addDomTargetListeners = () => {
      const {
        domTarget
      } = this.config;
      Object.entries(this.bindings).forEach((_ref2) => {
        let [event, fns] = _ref2;
        this.domListeners.push([event.substr(2).toLowerCase(), chainFns(...fns)]);
      });
      addListeners(domTarget, this.domListeners, this.config.event);
    };

    this.getBindings = () => {
      const output = {};
      const captureString = this.config.event.capture ? 'Capture' : '';
      Object.entries(this.bindings).forEach((_ref3) => {
        let [event, fns] = _ref3;
        const fnsArray = Array.isArray(fns) ? fns : [fns];
        const key = event + captureString;
        output[key] = chainFns(...fnsArray);
      });
      return output;
    };

    this.bind = function () {
      const actions = new Set(Object.keys(_this.handlers).filter(k => k.indexOf('on') === 0).map(k => {
        const match = k.match(/(on[A-Z][a-z]+)/);
        if (match) return match[1];
      }));
      const {
        domTarget
      } = _this.config;

      const genuineHandlers = _extends({}, _this.handlers);

      _this.cleanOnBind();

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (actions.has('onDrag')) {
        _this.addRecognizer(new DragRecognizer(_this, args));

        delete genuineHandlers.onDrag;
        delete genuineHandlers.onDragStart;
        delete genuineHandlers.onDragEnd;
      }

      if (actions.has('onScroll')) {
        _this.addRecognizer(new ScrollRecognizer(_this, args));

        delete genuineHandlers.onScroll;
        delete genuineHandlers.onScrollStart;
        delete genuineHandlers.onScrollEnd;
      }

      if (actions.has('onWheel')) {
        _this.addRecognizer(new WheelRecognizer(_this, args));

        delete genuineHandlers.onWheel;
        delete genuineHandlers.onWheelStart;
        delete genuineHandlers.onWheelEnd;
      }

      if (actions.has('onMove')) {
        _this.addRecognizer(new MoveRecognizer(_this, args));

        delete genuineHandlers.onMove;
        delete genuineHandlers.onMoveStart;
        delete genuineHandlers.onMoveEnd;
      }

      if (actions.has('onHover')) {
        _this.addRecognizer(new HoverRecognizer(_this, args));

        delete genuineHandlers.onHover;
      }

      if (actions.has('onPinch')) {
        if (domTarget && supportsGestureEvent()) {
          _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));
        } else {
          _this.addRecognizer(new PinchRecognizer(_this, args));

          _this.addRecognizer(new PinchWheelRecognizer(_this, args));
        }

        delete genuineHandlers.onPinch;
        delete genuineHandlers.onPinchStart;
        delete genuineHandlers.onPinchEnd;
      }

      Object.entries(genuineHandlers).map((_ref4) => {
        let [event, fn] = _ref4;

        _this.addEventBindings([event, fn]);
      });

      if (domTarget) {
        _this.addDomTargetListeners();

        return _this.clean;
      }

      return _this.getBindings();
    };

    this.setHandlersAndConfig(_handlers, _config);
  }

}

function useGesture(handlers, config) {
  const gestureController = React.useRef();

  if (!gestureController.current) {
    gestureController.current = new GestureController(handlers, config);
  }

  React.useEffect(() => {
    gestureController.current.setHandlersAndConfig(handlers, config);
  }, [handlers, config]);
  React.useEffect(() => gestureController.current.clean, []);
  return gestureController.current.bind;
}

export { useGesture };
