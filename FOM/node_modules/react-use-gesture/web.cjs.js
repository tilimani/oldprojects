'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = _interopDefault(require('react'));
var _extends = _interopDefault(require('@babel/runtime/helpers/extends'));
var _objectWithoutPropertiesLoose = _interopDefault(require('@babel/runtime/helpers/objectWithoutPropertiesLoose'));
var _inheritsLoose = _interopDefault(require('@babel/runtime/helpers/inheritsLoose'));

var GestureFlag;

(function (GestureFlag) {
  GestureFlag["OnStart"] = "start";
  GestureFlag["OnChange"] = "change";
  GestureFlag["OnEnd"] = "end";
})(GestureFlag || (GestureFlag = {}));

var noop = function noop() {};
var chainFns = function chainFns() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    return fns.forEach(function (fn) {
      return fn.apply(void 0, args);
    });
  };
};
var addV = function addV(v1, v2) {
  return v1.map(function (v, i) {
    return v + v2[i];
  });
};
var subV = function subV(v1, v2) {
  return v1.map(function (v, i) {
    return v - v2[i];
  });
};

var setListeners = function setListeners(add) {
  return function (el, listeners, options) {
    var action = add ? 'addEventListener' : 'removeEventListener';
    listeners.forEach(function (_ref) {
      var type = _ref[0],
          fn = _ref[1];
      return el[action](type, fn, options);
    });
  };
};

var addListeners = setListeners(true);
var removeListeners = setListeners(false);
function getModifierKeys(event) {
  var shiftKey = event.shiftKey,
      altKey = event.altKey,
      metaKey = event.metaKey,
      ctrlKey = event.ctrlKey;
  return {
    shiftKey: shiftKey,
    altKey: altKey,
    metaKey: metaKey,
    ctrlKey: ctrlKey
  };
}
function getScrollEventData(event) {
  var _ref2 = event.currentTarget,
      scrollX = _ref2.scrollX,
      scrollY = _ref2.scrollY,
      scrollLeft = _ref2.scrollLeft,
      scrollTop = _ref2.scrollTop;
  return _extends({
    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]
  }, getModifierKeys(event));
}
function getWheelEventData(event) {
  var deltaX = event.deltaX,
      deltaY = event.deltaY;
  return _extends({
    values: [deltaX, deltaY]
  }, getModifierKeys(event));
}
function getPointerEventData(event) {
  var _ref3 = event,
      touches = _ref3.touches,
      buttons = _ref3.buttons,
      changedTouches = _ref3.changedTouches;
  var touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;

  var _ref4 = touchEvents ? touchEvents[0] : event,
      clientX = _ref4.clientX,
      clientY = _ref4.clientY;

  var down = touchEvents && touchEvents.length > 0 || buttons > 0;
  return _extends({
    values: [clientX, clientY],
    touches: touchEvents && touchEvents.length || 0,
    down: down,
    buttons: buttons
  }, getModifierKeys(event));
}
function getTwoTouchesEventData(event) {
  var touches = event.touches;
  var dx = touches[1].clientX - touches[0].clientX;
  var dy = touches[1].clientY - touches[0].clientY;
  var da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];
  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];
  return _extends({
    values: da,
    origin: origin,
    touches: 2,
    down: touches.length > 0
  }, getModifierKeys(event));
}
function calculateVelocity(diff, delta_t, len) {
  len = len || Math.hypot.apply(Math, diff);
  return delta_t ? len / delta_t : 0;
}
function calculateVelocities(diff, delta_t) {
  return delta_t ? diff.map(function (v) {
    return v / delta_t;
  }) : Array(diff.length).fill(0);
}
function calculateDistance(delta) {
  return Math.hypot.apply(Math, delta);
}
function calculateDirection(diff, len) {
  len = len || Math.hypot.apply(Math, diff) || 1;
  return diff.map(function (v) {
    return v / len;
  });
}
function calculateAllKinematics(delta, diff, delta_t) {
  var len = Math.hypot.apply(Math, diff);
  return {
    velocities: calculateVelocities(diff, delta_t),
    velocity: calculateVelocity(diff, delta_t, len),
    distance: calculateDistance(delta),
    direction: calculateDirection(diff, len)
  };
}
function supportsGestureEvent() {
  try {
    return 'constructor' in GestureEvent;
  } catch (e) {
    return false;
  }
}

var mappedKeys = {
  drag: {
    stateKey: 'drag',
    handlerKey: 'onDrag'
  },
  pinch: {
    stateKey: 'pinch',
    handlerKey: 'onPinch'
  },
  move: {
    stateKey: 'move',
    handlerKey: 'onMove'
  },
  scroll: {
    stateKey: 'scroll',
    handlerKey: 'onScroll'
  },
  wheel: {
    stateKey: 'wheel',
    handlerKey: 'onWheel'
  },
  hover: {
    stateKey: 'move',
    handlerKey: 'onHover'
  }
};
var defaultConfig = {
  domTarget: undefined,
  event: {
    passive: true,
    capture: false
  },
  pointerEvents: false,
  window: typeof window !== 'undefined' ? window : undefined,
  transform: {
    x: function x(_x) {
      return _x;
    },
    y: function y(_y) {
      return _y;
    }
  },
  enabled: true,
  drag: true,
  pinch: true,
  scroll: true,
  wheel: true,
  hover: true,
  move: true
};
var initialCommon = {
  event: undefined,
  currentTarget: undefined,
  pointerId: undefined,
  values: [0, 0],
  velocities: [0, 0],
  delta: [0, 0],
  initial: [0, 0],
  previous: [0, 0],
  transform: undefined,
  local: [0, 0],
  lastLocal: [0, 0],
  first: false,
  last: false,
  active: false,
  time: undefined,
  cancel: noop,
  canceled: false,
  temp: undefined,
  args: undefined
};
var initialCoordinates = {
  xy: [0, 0],
  vxvy: [0, 0],
  velocity: 0,
  distance: 0,
  direction: [0, 0]
};
var initialDistanceAngle = {
  da: [0, 0],
  vdva: [0, 0],
  origin: [0, 0],
  turns: 0
};
var initialState = {
  shared: {
    hovering: false,
    scrolling: false,
    wheeling: false,
    dragging: false,
    moving: false,
    pinching: false,
    touches: 0,
    buttons: 0,
    down: false,
    shiftKey: false,
    altKey: false,
    metaKey: false,
    ctrlKey: false
  },
  move: _extends({}, initialCommon, initialCoordinates),
  drag: _extends({}, initialCommon, initialCoordinates),
  scroll: _extends({}, initialCommon, initialCoordinates),
  wheel: _extends({}, initialCommon, initialCoordinates),
  pinch: _extends({}, initialCommon, initialDistanceAngle)
};
var genericEndState = {
  first: false,
  last: true,
  active: false
};

var Recognizer = function Recognizer(gestureKey, controller, args) {
  var _this = this;

  if (args === void 0) {
    args = [];
  }

  this.gestureKey = gestureKey;
  this.controller = controller;
  this.args = args;
  this.stateKey = void 0;

  this.isEnabled = function () {
    return _this.controller.config.enabled && _this.controller.config[_this.gestureKey];
  };

  this.setTimeout = function (callback, ms) {
    var _window;

    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }

    _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));
  };

  this.clearTimeout = function () {
    clearTimeout(_this.controller.timeouts[_this.stateKey]);
  };

  this.getState = function () {
    return _this.controller.state[_this.stateKey];
  };

  this.getSharedState = function () {
    return _this.controller.state.shared;
  };

  this.pointerEventsEnabled = function () {
    return _this.controller.config.pointerEvents;
  };

  this.getTransformConfig = function () {
    return _this.controller.config.transform;
  };

  this.addWindowListeners = function (listeners) {
    _this.controller.addWindowListeners(_this.stateKey, listeners);
  };

  this.removeWindowListeners = function () {
    _this.controller.removeWindowListeners(_this.stateKey);
  };

  this.updateState = function (sharedState, gestureState, gestureFlag) {
    _this.controller.updateState(sharedState, gestureState, _this.gestureKey, gestureFlag);
  };

  this.getStartState = function (values, event) {
    var state = _this.getState();

    var initial = initialState[_this.stateKey];

    var transform = state.transform || event.transform || _this.getTransformConfig();

    var lastLocal = state.local || initial.local;
    return _extends({}, initial, {
      event: event,
      values: values,
      initial: values,
      previous: values,
      local: lastLocal,
      lastLocal: lastLocal,
      first: true,
      active: true,
      transform: transform,
      time: event.timeStamp,
      args: _this.args
    });
  };

  this.stateKey = mappedKeys[gestureKey].stateKey;
};

var CoordinatesRecognizer = function (_Recognizer) {
  _inheritsLoose(CoordinatesRecognizer, _Recognizer);

  function CoordinatesRecognizer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Recognizer.call.apply(_Recognizer, [this].concat(args)) || this;

    _this.getKinematics = function (values, event) {
      var state = _this.getState();

      var xy = state.values,
          initial = state.initial,
          lastLocal = state.lastLocal,
          _state$time = state.time,
          time = _state$time === void 0 ? 0 : _state$time;

      var transform = state.transform || event.transform || _this.getTransformConfig();

      var delta = subV(values, initial).map(function (v, i) {
        return Object.values(transform)[i](v);
      });
      var diff = subV(values, xy).map(function (v, i) {
        return Object.values(transform)[i](v);
      });
      var delta_t = event.timeStamp - time;

      var _calculateAllKinemati = calculateAllKinematics(delta, diff, delta_t),
          velocity = _calculateAllKinemati.velocity,
          velocities = _calculateAllKinemati.velocities,
          distance = _calculateAllKinemati.distance,
          direction = _calculateAllKinemati.direction;

      return {
        event: event,
        values: values,
        delta: delta,
        velocity: velocity,
        velocities: velocities,
        distance: distance,
        direction: direction,
        local: addV(lastLocal, delta),
        previous: xy,
        transform: transform,
        time: event.timeStamp
      };
    };

    return _this;
  }

  return CoordinatesRecognizer;
}(Recognizer);

var DragRecognizer = function (_CoordinatesRecognize) {
  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);

  function DragRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled()) return;

      var _getPointerEventData = getPointerEventData(event),
          values = _getPointerEventData.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      if (rest.touches > 1) return;
      var _ref = event,
          currentTarget = _ref.currentTarget,
          pointerId = _ref.pointerId;

      if (_this.pointerEventsEnabled()) {
        currentTarget && currentTarget.setPointerCapture(pointerId);
      } else {
        _this.removeWindowListeners();

        var dragListeners = [['mousemove', _this.onChange], ['mouseup', _this.onEnd], ['touchmove', _this.onChange], ['touchend', _this.onEnd], ['touchcancel', _this.onEnd]];

        _this.addWindowListeners(dragListeners);
      }

      var startState = _this.getStartState(values, event);

      _this.updateState(_extends({}, rest, {
        dragging: true,
        down: true
      }), _extends({}, startState, {
        currentTarget: currentTarget,
        pointerId: pointerId,
        cancel: function cancel() {
          return _this.onCancel(event);
        }
      }), GestureFlag.OnStart);
    };

    _this.onChange = function (event) {
      var _this$getState = _this.getState(),
          canceled = _this$getState.canceled,
          active = _this$getState.active;

      if (canceled || !active) return;

      var _getPointerEventData2 = getPointerEventData(event),
          values = _getPointerEventData2.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, ["values"]);

      if (rest.buttons === 0 && rest.touches === 0) {
        _this.onEnd(event);

        return;
      }

      var kinematics = _this.getKinematics(values, event);

      var cancel = function cancel() {
        return _this.onCancel(event);
      };

      _this.updateState(rest, _extends({}, kinematics, {
        first: false,
        cancel: cancel
      }), GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      var state = _this.getState();

      if (!state.active) return;
      var currentTarget = state.currentTarget,
          pointerId = state.pointerId;
      if (currentTarget && _this.pointerEventsEnabled()) currentTarget.releasePointerCapture(pointerId);else _this.removeWindowListeners();

      _this.updateState({
        dragging: false,
        down: false,
        buttons: 0,
        touches: 0
      }, _extends({}, genericEndState, {
        event: event
      }), GestureFlag.OnEnd);
    };

    _this.onCancel = function (event) {
      _this.updateState(null, {
        canceled: true,
        cancel: noop
      });

      requestAnimationFrame(function () {
        return _this.onEnd(event);
      });
    };

    return _this;
  }

  var _proto = DragRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]];
    }

    return [[['onMouseDown', 'onTouchStart'], this.onStart]];
  };

  return DragRecognizer;
}(CoordinatesRecognizer);

var ScrollRecognizer = function (_CoordinatesRecognize) {
  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);

  function ScrollRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled()) return;

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd, 100);

      var _getScrollEventData = getScrollEventData(event),
          values = _getScrollEventData.values,
          rest = _objectWithoutPropertiesLoose(_getScrollEventData, ["values"]);

      if (!_this.getState().active) {
        var startState = _this.getStartState(values, event);

        _this.updateState(_extends({
          scrolling: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics(values, event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        scrolling: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = ScrollRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onScroll', this.onChange]];
  };

  return ScrollRecognizer;
}(CoordinatesRecognizer);

var WheelRecognizer = function (_CoordinatesRecognize) {
  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);

  function WheelRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled()) return;

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd, 100);

      var _getWheelEventData = getWheelEventData(event),
          eventValues = _getWheelEventData.values,
          rest = _objectWithoutPropertiesLoose(_getWheelEventData, ["values"]);

      var values = addV(eventValues, _this.getState().values);

      if (!_this.getState().active) {
        var startState = _this.getStartState(values, event);

        _this.updateState(_extends({
          wheeling: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics(values, event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        wheeling: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = WheelRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onWheel', this.onChange]];
  };

  return WheelRecognizer;
}(CoordinatesRecognizer);

var MoveRecognizer = function (_CoordinatesRecognize) {
  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);

  function MoveRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled()) return;

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd, 100);

      var _getPointerEventData = getPointerEventData(event),
          values = _getPointerEventData.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      if (!_this.getState().active) {
        var startState = _this.getStartState(values, event);

        _this.updateState(_extends({
          moving: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics(values, event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        moving: false
      }, _extends({}, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = MoveRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerMove', this.onChange]];
    }

    return [['onMouseMove', this.onChange]];
  };

  return MoveRecognizer;
}(CoordinatesRecognizer);

var HoverRecognizer = function (_CoordinatesRecognize) {
  _inheritsLoose(HoverRecognizer, _CoordinatesRecognize);

  function HoverRecognizer(controller, args) {
    var _this;

    _this = _CoordinatesRecognize.call(this, 'hover', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled()) return;

      var _getPointerEventData = getPointerEventData(event),
          values = _getPointerEventData.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData, ["values"]);

      _this.updateState(_extends({
        hovering: true
      }, rest), {
        values: values,
        event: event,
        args: _this.args
      }, GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      if (!_this.isEnabled()) return;

      var _getPointerEventData2 = getPointerEventData(event),
          values = _getPointerEventData2.values,
          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, ["values"]);

      var kinematics = _this.getKinematics(values, event);

      _this.updateState(_extends({
        hovering: false,
        moving: false
      }, rest), _extends({}, kinematics, genericEndState, {
        velocity: 0,
        velocities: [0, 0]
      }));

      _this.controller.fireGestureHandler('move', GestureFlag.OnEnd);

      _this.controller.fireGestureHandler('hover', GestureFlag.OnChange);
    };

    return _this;
  }

  var _proto = HoverRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    if (this.pointerEventsEnabled()) {
      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]];
    }

    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]];
  };

  return HoverRecognizer;
}(CoordinatesRecognizer);

var DistanceAngleRecognizer = function (_Recognizer) {
  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);

  function DistanceAngleRecognizer() {
    var _this;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _Recognizer.call.apply(_Recognizer, [this].concat(args)) || this;

    _this.getKinematics = function (_ref, event) {
      var d = _ref[0],
          a = _ref[1];

      var state = _this.getState();

      var da = state.values,
          turns = state.turns,
          initial = state.initial,
          lastLocal = state.lastLocal,
          _state$time = state.time,
          time = _state$time === void 0 ? 0 : _state$time;
      a = a === undefined ? da[1] : a;
      var diff_d = d - da[0];
      var diff_a = a - da[1];
      var newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns;
      diff_a -= 360 * newTurns;
      var delta_d = d - initial[0];
      var delta_a = a - 360 * newTurns - initial[1];
      var delta = [delta_d, delta_a];
      var delta_t = event.timeStamp - time;
      var velocities = calculateVelocities([diff_d, diff_a], delta_t);
      return {
        event: event,
        values: [d, a],
        delta: delta,
        velocities: velocities,
        turns: newTurns,
        local: addV(lastLocal, delta),
        previous: da,
        time: event.timeStamp
      };
    };

    return _this;
  }

  return DistanceAngleRecognizer;
}(Recognizer);

var PinchRecognizer = function (_DistanceAngleRecogni) {
  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);

  function PinchRecognizer(controller, args) {
    var _this;

    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled() || event.touches.length !== 2) return;

      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),
          values = _getTwoTouchesEventDa.values,
          origin = _getTwoTouchesEventDa.origin,
          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, ["values", "origin"]);

      var startState = _this.getStartState(values, event);

      _this.updateState(_extends({}, rest, {
        pinching: true,
        down: true
      }), _extends({}, startState, {
        origin: origin,
        cancel: function cancel() {
          return _this.onCancel(event);
        }
      }), GestureFlag.OnStart);
    };

    _this.onChange = function (event) {
      var _this$getState = _this.getState(),
          canceled = _this$getState.canceled,
          active = _this$getState.active;

      if (canceled || !active || event.touches.length !== 2) return;

      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),
          values = _getTwoTouchesEventDa2.values,
          origin = _getTwoTouchesEventDa2.origin,
          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa2, ["values", "origin"]);

      var kinematics = _this.getKinematics(values, event);

      var cancel = function cancel() {
        return _this.onCancel(event);
      };

      _this.updateState(rest, _extends({}, kinematics, {
        origin: origin,
        first: false,
        cancel: cancel
      }), GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      if (!_this.getState().active) return;

      _this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState, {
        event: event
      }), GestureFlag.OnEnd);
    };

    _this.onCancel = function (event) {
      _this.updateState(null, {
        canceled: true,
        cancel: noop
      });

      requestAnimationFrame(function () {
        return _this.onEnd(event);
      });
    };

    return _this;
  }

  var _proto = PinchRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];
  };

  return PinchRecognizer;
}(DistanceAngleRecognizer);

var PinchWheelRecognizer = function (_DistanceAngleRecogni) {
  _inheritsLoose(PinchWheelRecognizer, _DistanceAngleRecogni);

  function PinchWheelRecognizer(controller, args) {
    var _this;

    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;

    _this.onChange = function (event) {
      if (!_this.isEnabled() || !event.ctrlKey) return;
      event.preventDefault();

      _this.clearTimeout();

      _this.setTimeout(_this.onEnd, 100);

      var _getWheelEventData = getWheelEventData(event),
          values = _getWheelEventData.values,
          rest = _objectWithoutPropertiesLoose(_getWheelEventData, ["values"]);

      var d = _this.getState().values[0] - values[1];

      if (!_this.getState().active) {
        var startState = _this.getStartState([d, 0], event);

        _this.updateState(_extends({
          pinching: true
        }, rest), startState, GestureFlag.OnStart);
      } else {
        var kinematics = _this.getKinematics([d, undefined], event);

        _this.updateState(rest, _extends({}, kinematics, {
          first: false
        }), GestureFlag.OnChange);
      }
    };

    _this.onEnd = function () {
      if (!_this.getState().active) return;

      _this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState), GestureFlag.OnEnd);
    };

    return _this;
  }

  var _proto = PinchWheelRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onWheel', this.onChange]];
  };

  return PinchWheelRecognizer;
}(DistanceAngleRecognizer);

var SCALE_FACTOR = 260;

var PinchWebKitGestureRecognizer = function (_DistanceAngleRecogni) {
  _inheritsLoose(PinchWebKitGestureRecognizer, _DistanceAngleRecogni);

  function PinchWebKitGestureRecognizer(controller, args) {
    var _this;

    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;

    _this.onStart = function (event) {
      if (!_this.isEnabled()) return;
      event.preventDefault();
      var da = [event.scale * SCALE_FACTOR, event.rotation];

      var startState = _this.getStartState(da, event);

      _this.updateState({
        pinching: true,
        down: true,
        touches: 2
      }, _extends({}, startState, {
        cancel: function cancel() {
          return _this.onCancel(event);
        }
      }), GestureFlag.OnStart);
    };

    _this.onChange = function (event) {
      var _this$getState = _this.getState(),
          canceled = _this$getState.canceled,
          active = _this$getState.active;

      if (canceled || !active) return;
      event.preventDefault();
      var da = [event.scale * SCALE_FACTOR, event.rotation];

      var kinematics = _this.getKinematics(da, event);

      var cancel = function cancel() {
        return _this.onCancel(event);
      };

      _this.updateState(null, _extends({}, kinematics, {
        first: false,
        cancel: cancel
      }), GestureFlag.OnChange);
    };

    _this.onEnd = function (event) {
      if (!_this.getState().active) return;
      event.preventDefault();

      _this.updateState({
        pinching: false,
        down: false,
        touches: 0
      }, _extends({}, genericEndState, {
        event: event
      }), GestureFlag.OnEnd);
    };

    _this.onCancel = function (event) {
      _this.updateState(null, {
        canceled: true,
        cancel: noop
      });

      requestAnimationFrame(function () {
        return _this.onEnd(event);
      });
    };

    _this.updateTouchData = function (event) {
      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),
          origin = _getTwoTouchesEventDa.origin;

      _this.updateState(null, {
        origin: origin
      });
    };

    return _this;
  }

  var _proto = PinchWebKitGestureRecognizer.prototype;

  _proto.getEventBindings = function getEventBindings() {
    return [['onGestureStart', this.onStart], ['onGestureChange', this.onChange], [['onGestureEnd', 'onTouchCancel'], this.onEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];
  };

  return PinchWebKitGestureRecognizer;
}(DistanceAngleRecognizer);

var GestureController = function GestureController(_handlers, _config) {
  var _this = this;

  this.handlers = void 0;
  this.config = void 0;
  this.state = initialState;
  this.timeouts = {};
  this.bindings = {};
  this.domListeners = [];
  this.windowListeners = {};

  this.setHandlersAndConfig = function (handlers, config) {
    if (typeof handlers === 'function') handlers = {
      onDrag: handlers
    };else if (handlers.onAction) {
      handlers.onDrag = handlers.onAction;
      delete handlers.onAction;
    }
    _this.config = _extends({}, defaultConfig, config);
    var domTarget = _this.config.domTarget;
    var realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;
    _this.config.domTarget = realDomTarget;
    _this.handlers = handlers;
  };

  this.clean = function () {
    _this.cleanOnBind();

    Object.values(_this.timeouts).forEach(clearTimeout);
    Object.keys(_this.windowListeners).forEach(function (stateKey) {
      return _this.removeWindowListeners(stateKey);
    });
  };

  this.cleanOnBind = function () {
    _this.bindings = {};
    var domTarget = _this.config.domTarget;

    if (domTarget) {
      removeListeners(domTarget, _this.domListeners, _this.config.event);
      _this.domListeners = [];
    }
  };

  this.updateState = function (sharedState, gestureState, gestureKey, gestureFlag) {
    var _extends2;

    var stateKey = mappedKeys[gestureKey].stateKey;
    _this.state = _extends({}, _this.state, (_extends2 = {
      shared: _extends({}, _this.state.shared, sharedState)
    }, _extends2[stateKey] = _extends({}, _this.state[stateKey], gestureState), _extends2));

    if (gestureFlag) {
      _this.fireGestureHandler(gestureKey, gestureFlag);
    }
  };

  this.fireGestureHandler = function (gestureKey, gestureFlag) {
    var _mappedKeys$gestureKe = mappedKeys[gestureKey],
        stateKey = _mappedKeys$gestureKe.stateKey,
        handlerKey = _mappedKeys$gestureKe.handlerKey;

    var state = _extends({}, _this.state.shared, _this.state[stateKey]);

    if (gestureKey === 'pinch') {
      var pinchState = state;
      pinchState.da = state.values;
      pinchState.vdva = state.velocities;
    } else {
      var coordinatesState = state;
      coordinatesState.xy = state.values;
      coordinatesState.vxvy = state.velocities;
    }

    if (gestureFlag === GestureFlag.OnStart) {
      var handlerStart = handlerKey + "Start";
      var _handler = _this.handlers[handlerStart];
      _handler && _handler(state);
    }

    var handler = _this.handlers[handlerKey];

    if (handler) {
      _this.state[stateKey].temp = handler(state) || _this.state[stateKey].temp;
    }

    if (gestureFlag === GestureFlag.OnEnd) {
      var handlerEnd = handlerKey + "End";
      var _handler2 = _this.handlers[handlerEnd];
      _handler2 && _handler2(state);
    }
  };

  this.addWindowListeners = function (stateKey, listeners) {
    if (!_this.config.window) return;
    _this.windowListeners[stateKey] = listeners;
    addListeners(_this.config.window, listeners, _this.config.event);
  };

  this.removeWindowListeners = function (stateKey) {
    if (!_this.config.window) return;
    var listeners = _this.windowListeners[stateKey];

    if (listeners) {
      removeListeners(_this.config.window, listeners, _this.config.event);
      delete _this.windowListeners[stateKey];
    }
  };

  this.addRecognizer = function (recognizer) {
    recognizer.getEventBindings().map(_this.addEventBindings);
  };

  this.addEventBindings = function (_ref) {
    var eventNames = _ref[0],
        fn = _ref[1];
    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;
    eventNamesArray.forEach(function (eventName) {
      _this.bindings[eventName] = _this.bindings[eventName] ? [].concat(_this.bindings[eventName], [fn]) : [fn];
    });
  };

  this.addDomTargetListeners = function () {
    var domTarget = _this.config.domTarget;
    Object.entries(_this.bindings).forEach(function (_ref2) {
      var event = _ref2[0],
          fns = _ref2[1];

      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);
    });
    addListeners(domTarget, _this.domListeners, _this.config.event);
  };

  this.getBindings = function () {
    var output = {};
    var captureString = _this.config.event.capture ? 'Capture' : '';
    Object.entries(_this.bindings).forEach(function (_ref3) {
      var event = _ref3[0],
          fns = _ref3[1];
      var fnsArray = Array.isArray(fns) ? fns : [fns];
      var key = event + captureString;
      output[key] = chainFns.apply(void 0, fnsArray);
    });
    return output;
  };

  this.bind = function () {
    var actions = new Set(Object.keys(_this.handlers).filter(function (k) {
      return k.indexOf('on') === 0;
    }).map(function (k) {
      var match = k.match(/(on[A-Z][a-z]+)/);
      if (match) return match[1];
    }));
    var domTarget = _this.config.domTarget;

    var genuineHandlers = _extends({}, _this.handlers);

    _this.cleanOnBind();

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (actions.has('onDrag')) {
      _this.addRecognizer(new DragRecognizer(_this, args));

      delete genuineHandlers.onDrag;
      delete genuineHandlers.onDragStart;
      delete genuineHandlers.onDragEnd;
    }

    if (actions.has('onScroll')) {
      _this.addRecognizer(new ScrollRecognizer(_this, args));

      delete genuineHandlers.onScroll;
      delete genuineHandlers.onScrollStart;
      delete genuineHandlers.onScrollEnd;
    }

    if (actions.has('onWheel')) {
      _this.addRecognizer(new WheelRecognizer(_this, args));

      delete genuineHandlers.onWheel;
      delete genuineHandlers.onWheelStart;
      delete genuineHandlers.onWheelEnd;
    }

    if (actions.has('onMove')) {
      _this.addRecognizer(new MoveRecognizer(_this, args));

      delete genuineHandlers.onMove;
      delete genuineHandlers.onMoveStart;
      delete genuineHandlers.onMoveEnd;
    }

    if (actions.has('onHover')) {
      _this.addRecognizer(new HoverRecognizer(_this, args));

      delete genuineHandlers.onHover;
    }

    if (actions.has('onPinch')) {
      if (domTarget && supportsGestureEvent()) {
        _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));
      } else {
        _this.addRecognizer(new PinchRecognizer(_this, args));

        _this.addRecognizer(new PinchWheelRecognizer(_this, args));
      }

      delete genuineHandlers.onPinch;
      delete genuineHandlers.onPinchStart;
      delete genuineHandlers.onPinchEnd;
    }

    Object.entries(genuineHandlers).map(function (_ref4) {
      var event = _ref4[0],
          fn = _ref4[1];

      _this.addEventBindings([event, fn]);
    });

    if (domTarget) {
      _this.addDomTargetListeners();

      return _this.clean;
    }

    return _this.getBindings();
  };

  this.setHandlersAndConfig(_handlers, _config);
};

function useGesture(handlers, config) {
  var gestureController = React.useRef();

  if (!gestureController.current) {
    gestureController.current = new GestureController(handlers, config);
  }

  React.useEffect(function () {
    gestureController.current.setHandlersAndConfig(handlers, config);
  }, [handlers, config]);
  React.useEffect(function () {
    return gestureController.current.clean;
  }, []);
  return gestureController.current.bind;
}

exports.useGesture = useGesture;
